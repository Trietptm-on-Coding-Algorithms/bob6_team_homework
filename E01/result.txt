[step1] - 원본 disassemble code

   0x0000000000400543 <+0>:	push   rbp
   0x0000000000400544 <+1>:	mov    rbp,rsp
   0x0000000000400547 <+4>:	sub    rsp,0x10
   0x000000000040054b <+8>:	mov    DWORD PTR [rbp-0x4],0x1
   0x0000000000400552 <+15>:	mov    edx,0x3
   0x0000000000400557 <+20>:	mov    esi,0x2
   0x000000000040055c <+25>:	mov    edi,0x1
   0x0000000000400561 <+30>:	call   0x400526 <foo>
   0x0000000000400566 <+35>:	mov    DWORD PTR [rbp-0x4],eax
   0x0000000000400569 <+38>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040056c <+41>:	mov    esi,eax
   0x000000000040056e <+43>:	mov    edi,0x400614
   0x0000000000400573 <+48>:	mov    eax,0x0
   0x0000000000400578 <+53>:	call   0x400400 <printf@plt>
   0x000000000040057d <+58>:	mov    eax,0x0
   0x0000000000400582 <+63>:	leave
   0x0000000000400583 <+64>:	ret


[step2] - 함수 프롤로그 처리

-----------------------------------------------------------------
   0x0000000000400543 <+0>:	push   rbp
   0x0000000000400544 <+1>:	mov    rbp,rsp
   0x0000000000400547 <+4>:	sub    rsp,0x10
-----------------------------------------------------------------
	-> int main(){
	
	}
-----------------------------------------------------------------
   0x000000000040054b <+8>:	mov    DWORD PTR [rbp-0x4],0x1
   0x0000000000400552 <+15>:	mov    edx,0x3
   0x0000000000400557 <+20>:	mov    esi,0x2
   0x000000000040055c <+25>:	mov    edi,0x1
   0x0000000000400561 <+30>:	call   0x400526 <foo>
   0x0000000000400566 <+35>:	mov    DWORD PTR [rbp-0x4],eax
   0x0000000000400569 <+38>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040056c <+41>:	mov    esi,eax
   0x000000000040056e <+43>:	mov    edi,0x400614
   0x0000000000400573 <+48>:	mov    eax,0x0
   0x0000000000400578 <+53>:	call   0x400400 <printf@plt>
   0x000000000040057d <+58>:	mov    eax,0x0
   0x0000000000400582 <+63>:	leave
   0x0000000000400583 <+64>:	ret


[step3] - 지역 변수 처리

-----------------------------------------------------------------
   0x000000000040054b <+8>:	mov    DWORD PTR [rbp-0x4],0x1
-----------------------------------------------------------------
	-> ? main(){
		v4 = 1;
	}
-----------------------------------------------------------------
   0x0000000000400552 <+15>:	mov    edx,0x3
   0x0000000000400557 <+20>:	mov    esi,0x2
   0x000000000040055c <+25>:	mov    edi,0x1
   0x0000000000400561 <+30>:	call   0x400526 <foo>
   0x0000000000400566 <+35>:	mov    DWORD PTR [rbp-0x4],eax
   0x0000000000400569 <+38>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040056c <+41>:	mov    esi,eax
   0x000000000040056e <+43>:	mov    edi,0x400614
   0x0000000000400573 <+48>:	mov    eax,0x0
   0x0000000000400578 <+53>:	call   0x400400 <printf@plt>
   0x000000000040057d <+58>:	mov    eax,0x0
   0x0000000000400582 <+63>:	leave
   0x0000000000400583 <+64>:	ret


[step4] - foo 함수 처리

-----------------------------------------------------------------
   0x0000000000400552 <+15>:	mov    edx,0x3
   0x0000000000400557 <+20>:	mov    esi,0x2
   0x000000000040055c <+25>:	mov    edi,0x1
   0x0000000000400561 <+30>:	call   0x400526 <foo>
   0x0000000000400566 <+35>:	mov    DWORD PTR [rbp-0x4],eax
-----------------------------------------------------------------
	x64는 fastcall 함수호출규약을 사용하므로,
	mov general register, ? 의 assembly code를 인식하는 경우, 
	해당 레지스터의 임시 buf를 만들어서 저장해 놓는다.
	만약 instruction이 call인 경우, 범용레지스터에서 
	(rdi, edi), (rsi, esi), (rdx, edx), (rcx, ecx) 등의 순서로 함수인자를 처리한다. 
	또한, call instruction이 발생한 이후 eax레지스터의 값을 사용하는 경우 해당 함수의 return 값으로 처리한다.
	
	-> int main(){
		v4 = 1;
		v4 = foo(0x1, 0x2, 0x3);
	}
-----------------------------------------------------------------

   0x000000000040056c <+41>:	mov    esi,eax
   0x000000000040056e <+43>:	mov    edi,0x400614
   0x0000000000400573 <+48>:	mov    eax,0x0
   0x0000000000400578 <+53>:	call   0x400400 <printf@plt>
   0x000000000040057d <+58>:	mov    eax,0x0
   0x0000000000400582 <+63>:	leave
   0x0000000000400583 <+64>:	ret


[step5] - printf 함수 처리

-----------------------------------------------------------------
   0x0000000000400569 <+38>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040056c <+41>:	mov    esi,eax
   0x000000000040056e <+43>:	mov    edi,0x400614
   0x0000000000400573 <+48>:	mov    eax,0x0
   0x0000000000400578 <+53>:	call   0x400400 <printf@plt>
-----------------------------------------------------------------
	[step4]와 마찬가지로 fastcall 함수호출규약에 따라 printf함수의 인자를 결정한다.
	
	int main(){
		v4 = 1;
		v4 = foo(0x1, 0x2, 0x3);
		//eax = v4;
		//printf(0x400614, eax);
		printf(0x400614, v4);	// eax 임시변수에는 v4가 들어가 있으므로 printf 인자처리를 할 때는, v4가 들어간다. 
	}
-----------------------------------------------------------------
   0x000000000040057d <+58>:	mov    eax,0x0
   0x0000000000400582 <+63>:	leave
   0x0000000000400583 <+64>:	ret


[step6] - main 함수의 리턴값 처리 및 함수 에필로그

-----------------------------------------------------------------
   0x000000000040057d <+58>:	mov    eax,0x0
   0x0000000000400582 <+63>:	leave
   0x0000000000400583 <+64>:	ret
-----------------------------------------------------------------
	ret 인스트럭션을 통해 함수가 종료되는 것을 확인하고, eax에 있는 값을 return 한다.

	int main(){
		v4 = 1;
		v4 = foo(0x1, 0x2, 0x3);
		printf(0x400614, v4);
		return 0;	 
	}
-----------------------------------------------------------------






[step1] - 함수의 프롤로그
-----------------------------------------------------------------
   0x0000000000400526 <+0>:	push   rbp
   0x0000000000400527 <+1>:	mov    rbp,rsp
-----------------------------------------------------------------
	int foo(int a1, int a2, int a3){
				
	}
-----------------------------------------------------------------
   0x000000000040052a <+4>:	mov    DWORD PTR [rbp-0x4],edi
   0x000000000040052d <+7>:	mov    DWORD PTR [rbp-0x8],esi
   0x0000000000400530 <+10>:	mov    DWORD PTR [rbp-0xc],edx
   0x0000000000400533 <+13>:	mov    eax,DWORD PTR [rbp-0x8]
   0x0000000000400536 <+16>:	imul   eax,DWORD PTR [rbp-0xc]
   0x000000000040053a <+20>:	mov    edx,eax
   0x000000000040053c <+22>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040053f <+25>:	add    eax,edx
   0x0000000000400541 <+27>:	pop    rbp
   0x0000000000400542 <+28>:	ret


[step2] - 지역변수 처리
-----------------------------------------------------------------
   0x000000000040052a <+4>:	mov    DWORD PTR [rbp-0x4],edi
   0x000000000040052d <+7>:	mov    DWORD PTR [rbp-0x8],esi
   0x0000000000400530 <+10>:	mov    DWORD PTR [rbp-0xc],edx
-----------------------------------------------------------------
	함수호출규약에 따라 (rdi, edi), (rsi, esi), (rdx, edx), (rcx, ecx) 등의 순서로 함수의 인자로 처리한다.
	함수의 인자는 a? 로 처리한다.

	int foo(int a1, int a2, int a3){
		v4 = a1;
		v8 = a2;
		vC = a3;			
	}
-----------------------------------------------------------------
   0x0000000000400533 <+13>:	mov    eax,DWORD PTR [rbp-0x8]
   0x0000000000400536 <+16>:	imul   eax,DWORD PTR [rbp-0xc]
   0x000000000040053a <+20>:	mov    edx,eax
   0x000000000040053c <+22>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040053f <+25>:	add    eax,edx
   0x0000000000400541 <+27>:	pop    rbp
   0x0000000000400542 <+28>:	ret

[step3] - imul instruction 처리

-----------------------------------------------------------------
   0x0000000000400533 <+13>:	mov    eax,DWORD PTR [rbp-0x8]
   0x0000000000400536 <+16>:	imul   eax,DWORD PTR [rbp-0xc]
-----------------------------------------------------------------
	int foo(int a1, int a2, int a3){
		int v4 = a1;
		int v8 = a2;
		int vC = a3;	
		// eax = v8;
		// eax = eax * vC;
		// eax 임시변수에는 v8가 들어가 있으므로 imul 연산의 operand 처리에서, v8가 들어간다.
		eax = v8 * vC;		
	}
-----------------------------------------------------------------
   0x000000000040053a <+20>:	mov    edx,eax
   0x000000000040053c <+22>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040053f <+25>:	add    eax,edx
   0x0000000000400541 <+27>:	pop    rbp
   0x0000000000400542 <+28>:	ret

[step4] - add instruction 처리 및 함수의 에필로그

-----------------------------------------------------------------
   0x000000000040053a <+20>:	mov    edx,eax
   0x000000000040053c <+22>:	mov    eax,DWORD PTR [rbp-0x4]
   0x000000000040053f <+25>:	add    eax,edx
   0x0000000000400541 <+27>:	pop    rbp
   0x0000000000400542 <+28>:	ret
-----------------------------------------------------------------
	ret 인스트럭션을 통해 함수가 종료되는 것을 확인하고, eax에 있는 값을 return 한다.
	범용레지스터는 각각 임시변수로 사용되기 때문에, 모두 치환하여 처리한다.	

	int foo(int a1, int a2, int a3){
		int v4 = a1;
		int v8 = a2;
		int vC = a3;
		-----------------치환 이전	
		//eax = v8 * vC;
		//edx = eax;
		//eax = v4;
		//eax = eax+edx;
		//return eax;
		-----------------

		//edx = v8 * vC		// edx 치환.
		//eax = v4 + v8 * vC	// eax 치환.
		return v4 + v8 * vC	// eax 레지스터 값을 리턴함.	
	}
